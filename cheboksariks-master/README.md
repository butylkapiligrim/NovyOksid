## Модуль обработки транзакций

Этот модуль предназначен для обработки данных о финансовых транзакциях, хранящихся в JSON-файле.

### Функции

#### `read_json_f(file_path: Path) -> List[Dict[str, Any]]`

* Описание: Чтение данных о транзакциях из JSON-файла.
* Входные данные: Путь к файлу с транзакциями.
* Выходные данные: Список словарей, где каждый словарь представляет одну транзакцию.
* Логика:
    * Открывает файл по указанному пути в режиме чтения с кодировкой UTF-8.
    * Использует `json.load()` для преобразования JSON-данных в список словарей.
    * Если данные в файле не являются списком, возвращает пустой список.
    * Обрабатывает ошибки `FileNotFoundError` и `json.JSONDecodeError`, возвращая пустой список в случае возникновения этих ошибок.

#### `get_curr_rate(currency: Any) -> Any`

* Описание: Получение актуального курса валюты с помощью API.
* Входные данные: Код валюты (например, "USD", "EUR").
* Выходные данные: Текущий курс валюты по отношению к рублю в формате float.
* Логика:
    * Формирует URL для запроса к API с использованием кода валюты.
    * Выполняет GET-запрос к API с использованием библиотеки `requests`.
    * Обрабатывает ошибки HTTP-запросов с помощью `response.raise_for_status()`.
    * Извлекает курс валюты из полученного JSON-ответа.
    * Возвращает полученный курс валюты.
    * Если возникла ошибка при обращении к API, выводит сообщение об ошибке и возвращает значение 1.0 по умолчанию.

#### `summ_amount(transaction: dict) -> float`

* Описание: Подсчет общей суммы транзакции в рублях с учетом конвертации валют.
* Входные данные: Словарь с данными о транзакции.
* Выходные данные: Сумма транзакции в рублях в формате float.
* Логика:
    * Извлекает валюту транзакции из словаря.
    * Если валюта – рубли, добавляет сумму к общей сумме.
    * Если валюта – евро или доллары, вызывает функцию `get_curr_rate()` для получения текущего курса и переводит сумму в рубли, а затем добавляет к общей сумме.
    * Возвращает общую сумму в рублях.

### Пример использования

В примере кода функция `summ_amount()` вызывается с образцом данных о транзакции, и результат – общая сумма в рублях – выводится на экран.

### Рекомендации

* При работе с внешними API рекомендуется использовать механизмы обработки ошибок и ограничений запросов, чтобы избежать блокировки аккаунта.
* Для хранения данных о транзакциях рекомендуется использовать структурированные форматы данных, такие как JSON или CSV, которые легко обрабатываются и анализируются.## Тестирование модуля обработки транзакций

Этот модуль содержит набор юнит-тестов для проверки функций, описанных в модуле обработки транзакций.

### Тесты

#### `test_get_transaction_ruble_api_error(mock_get: Mock) -> None`

* Описание: Тестирует функцию `get_curr_rate()` при возникновении ошибки HTTP-запроса.
* Логика:
    * Создает мок-объект для `requests.get()`, имитирующий ошибку при вызове `raise_for_status()`.
    * Вызывает `get_curr_rate()` с мок-объектом, имитирующим ошибку.
    * Проверяет, что функция возвращает значение по умолчанию 1.0 в случае ошибки.

#### `test_get_transaction_ruble_api_success(mock_get: MagicMock) -> None`

* Описание: Тестирует функцию `get_curr_rate()` при успешном HTTP-запросе.
* Логика:
    * Создает мок-объект для `requests.get()`, имитирующий успешный ответ API с курсом валюты.
    * Вызывает `get_curr_rate()` с мок-объектом.
    * Проверяет, что функция возвращает правильный курс валюты.

#### `test_read_transactions_works(mock_open: MagicMock) -> None`

* Описание: Тестирует функцию `read_json_f()` при наличии тестового JSON-файла.
* Логика:
    * Создает мок-объект для `builtins.open()`, имитирующий открытие тестового файла.
    * Задает мок-файлу тестовые JSON-данные с помощью `mock_open.return_value.read.return_value`.
    * Вызывает `read_json_f()` с мок-файлом.
    * Проверяет, что функция возвращает правильный список транзакций.

#### `test_read_transactions_emp_file() -> None`

* Описание: Тестирует функцию `read_json_f()` при работе с пустым JSON-файлом.
* Логика:
    * Создает пустой тестовый JSON-файл.
    * Вызывает `read_json_f()` с мок-файлом.
    * Проверяет, что функция возвращает пустой список.

#### `test_sums_amount() -> None`

* Описание: Тестирует функцию `summ_amount()` с образцом данных о транзакции.
* Логика:
    * Вызывает `summ_amount()` с образцом данных о транзакции.
    * Проверяет, что функция возвращает правильную сумму транзакции.

### Заметки

* В модуле используется библиотека `unittest.mock` для создания мок-объектов, имитирующих поведение внешних функций и файлов.
* В тестах используется `patch` для замены реальных функций и файлов мок-объектами.
* Тесты покрывают основные сценарии работы функций: успешный результат, ошибки, обработка пустых данных.

### Рекомендации

* Для расширения тестового покрытия рекомендуется добавить тесты для следующих случаев:
    * Обработка ошибок при конвертации валюты.
    * Проверка корректности формата входных данных.
    * Тестирование функций с различными типами входных данных.

* Рекомендуется использовать фреймворк тестирования, такой как pytest, для более удобной организации и запуска тестов.
* ## Модуль обработки транзакций

Этот модуль предоставляет функции для работы с данными о транзакциях, хранящимися в различных форматах файлов (CSV, XLSX, JSON).

### Функции

#### `read_transact_csv(file_path: str) -> list`

* Описание: Чтение данных о транзакциях из CSV-файла.
* Входные данные: Путь к CSV-файлу.
* Выходные данные: Список словарей, где каждый словарь представляет одну транзакцию.
* Логика:
    * Проверяет, что файл имеет расширение ".csv".
    * Использует библиотеку `pandas` для чтения CSV-файла.
    * Преобразует DataFrame в список словарей с помощью `to_dict(orient="records")`.
    * Возвращает список словарей.
    * В случае некорректного формата файла выводит сообщение об ошибке и возвращает пустой список.

#### `read_transact_xlsx(file_path: str) -> List[Dict]`

* Описание: Чтение данных о транзакциях из XLSX-файла.
* Входные данные: Путь к XLSX-файлу.
* Выходные данные: Список словарей, где каждый словарь представляет одну транзакцию.
* Логика:
    * Использует библиотеку `pandas` для чтения XLSX-файла.
    * Преобразует DataFrame в список словарей с помощью `to_dict("records")`.
    * Возвращает список словарей.

#### `read_transact_from_json(file_path: str) -> Any`

* Описание: Чтение данных о транзакциях из JSON-файла.
* Входные данные: Путь к JSON-файлу.
* Выходные данные: Список словарей, где каждый словарь представляет одну транзакцию.
* Логика:
    * Открывает JSON-файл в режиме чтения с кодировкой UTF-8.
    * Использует `json.load()` для загрузки JSON-данных в список словарей.
    * Возвращает список словарей.

#### `search_transact(transactions_1: List[Dict[str, Any]], search_string: str) -> List[Dict[str, Any]]`

* Описание: Поиск транзакций по поисковой строке в поле "description".
* Входные данные: Список словарей с транзакциями, поисковая строка.
* Выходные данные: Отфильтрованный список словарей с транзакциями, где в поле "description" найдена поисковая строка.
* Логика:
    * Использует списковое включение для фильтрации списка транзакций.
    * Проверяет наличие поля "description" в каждом словаре.
    * Использует регулярное выражение `re.search()` для поиска поисковой строки в поле "description".
    * Возвращает отфильтрованный список словарей.

#### `categorize_transact(transactions_2: List[Dict[str, Any]], categories_2: Dict[str, List[str]]) -> Dict[str, int]`

* Описание: Категоризация транзакций по ключевым словам.
* Входные данные: Список словарей с транзакциями, словарь с категориями и ключевыми словами.
* Выходные данные: Словарь, где ключи – названия категорий, а значения – количество транзакций в каждой категории.
* Логика:
    * Инициализирует пустой словарь `category_counts_2`.
    * Проходит по списку транзакций.
    * Для каждой транзакции проверяет наличие поля "description".
    * Проходит по категориям в словаре `categories_2`.
    * Проверяет, есть ли хотя бы одно ключевое слово из списка ключевых слов категории в описании транзакции (с учетом регистра).
    * Если совпадение найдено, увеличивает счетчик для этой категории в словаре `category_counts_2`.
    * Возвращает словарь `category_counts_2`.

### Примеры использования

* Примеры использования функций приведены в коде модуля.

### Рекомендации

* Для обработки больших объемов данных рекомендуется использовать оптимизированные алгоритмы и структуры данных.
* При работе с внешними файлами рекомендуется использовать обработку ошибок для предотвращения сбоев программы.